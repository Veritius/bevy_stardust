mod events;
mod framing;
mod header;
mod incoming;

use crate::Connection;
use bytes::Bytes;

pub(crate) use incoming::IncomingStream;

pub use events::StreamEvent;

impl Connection {
    /// Call when a new incoming stream is opened.
    pub fn stream_open(&mut self, stream: RecvStreamId) {
        self.incoming_streams.insert(stream, IncomingStream::new());
    }

    /// Call when a chunk of data is received on a stream.
    pub fn stream_recv(&mut self, stream: RecvStreamId, chunk: Bytes) {
        if !self.incoming_streams.contains_key(&stream) {
            self.stream_open(stream);
        }

        let stream = self.incoming_streams.get_mut(&stream).unwrap();
        stream.push(chunk);

        todo!()
    }

    /// Call when a stream is reset.
    pub fn stream_reset(&mut self, stream: RecvStreamId) {
        self.incoming_streams.remove(&stream);
    }

    /// Call when a stream is finished.
    pub fn stream_finished(&mut self, stream: RecvStreamId) {
        self.incoming_streams.remove(&stream);
    }

    /// Call when a stream is stopped.
    pub fn stream_stopped(&mut self, stream: SendStreamId) {
        todo!()
    }
}

/// A stream identifier for an **outgoing** (sending) QUIC stream.
/// 
/// Generated by the state machine.
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct SendStreamId(pub u64);

/// A stream identifier for an **incoming** (receiving) QUIC stream.
/// 
/// Generated by the QUIC implementation.
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct RecvStreamId(pub u64);