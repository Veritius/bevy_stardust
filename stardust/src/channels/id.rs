//! Types and traits for accessing channels.

use std::marker::PhantomData;
use bevy::prelude::*;

/// Identifier for a channel. Used to access writing and reading functionality.
/// Automatically implemented, just derive `Debug` and `Reflect` (or `TypePath`).
/// 
/// ```rs
/// #[derive(Debug, Reflect)]
/// pub struct MyChannel;
/// ```
pub trait Channel: TypePath + std::fmt::Debug + Send + Sync + 'static {}
impl<T: TypePath + std::fmt::Debug + Send + Sync + 'static> Channel for T {}

/// Typed marker component for filtering channel entities.
#[derive(Component)]
pub(super) struct ChannelMarker<C: Channel>(pub PhantomData<C>);

impl<C: Channel> Default for ChannelMarker<C> {
    fn default() -> Self {
        Self(Default::default())
    }
}

/// The maximum amount of channels that can exist.
pub const CHANNEL_ID_LIMIT: u32 = 2u32.pow(24);

/// A unique 24-bit channel identifier. Uses a `u32` internally.
/// 
/// Channel identifiers are generated by the `ChannelRegistry` and are unique to the `World` they originated from.
/// Attempting to use a `ChannelId` in another `World` will probably panic, or give you unintended results.
#[derive(Debug, Clone, Copy, Hash, Reflect, PartialEq, Eq, PartialOrd, Ord)]
pub struct ChannelId(u32);

impl TryFrom<u32> for ChannelId {
    type Error = ();

    fn try_from(value: u32) -> Result<Self, Self::Error> {
        if value > CHANNEL_ID_LIMIT { return Err(()) }
        Ok(Self(value))
    }
}

impl From<[u8;3]> for ChannelId {
    fn from(value: [u8;3]) -> Self {
        Self(u32::from_le_bytes([value[0], value[1], value[2], 0].into()))
    }
}

impl From<ChannelId> for u32 {
    fn from(value: ChannelId) -> Self {
        value.0
    }
}

impl From<ChannelId> for [u8;3] {
    fn from(value: ChannelId) -> Self {
        let value = value.0.to_le_bytes();
        [value[0], value[1], value[2]]
    }
}