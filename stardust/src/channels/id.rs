//! Types and traits for accessing channels.

use std::marker::PhantomData;
use bevy::prelude::*;

/// Types that can be used to interface with Stardust's message reading and writing APIs.
/// 
/// ```
/// // Defining a channel type is simple
/// #[derive(TypePath)]
/// pub struct MyChannel;
/// 
/// // You can make channels private
/// #[derive(TypePath)]
/// struct MyPrivateChannel;
/// 
/// // You can make channels with generic type bounds too
/// #[derive(TypePath)]
/// struct MyGenericChannel<T: Channel>(PhantomData<T>);
/// ```
/// 
/// In Stardust, `Channel` trait objects are just used for their type data.
/// The type itself isn't actually stored. That means you can do things like this.
/// 
/// ```
/// #[derive(TypePath, Event)]
/// pub struct MovementEvent(pub Vec3);
///
/// fn main() {
///     app.add_event::<MovementEvent>();
///     app.add_channel::<MovementEvent>();
///     app.add_system(PostUpdate, |mut events: EventReader<MovementEvent>, mut writer: NetworkWriter<MovementEvent>| {
///         let target = Entity::PLACEHOLDER;
///         for event in events.iter() {
///             let bytes = &[0u8;32]; // Some kind of serialisation logic
///             writer.send(target, bytes.into());
///         }
///     });
/// }
/// ```
pub trait Channel: TypePath + Send + Sync + 'static {}
impl<T: TypePath + Send + Sync + 'static> Channel for T {}

/// Typed marker component for filtering channel entities.
#[derive(Component)]
pub(super) struct ChannelMarker<C: Channel>(pub PhantomData<C>);

impl<C: Channel> Default for ChannelMarker<C> {
    fn default() -> Self {
        Self(Default::default())
    }
}

/// A sequential channel identifier that can be used to access data without type information.
/// 
/// Channel identifiers are generated by the `ChannelRegistry` and are unique to the `World` they originated from.
/// Attempting to use a `ChannelId` in another `World` will probably panic, or give you unintended results.
#[derive(Debug, Clone, Copy, Hash, Reflect, PartialEq, Eq, PartialOrd, Ord)]
pub struct ChannelId(u32);

impl From<u32> for ChannelId {
    fn from(value: u32) -> Self {
        Self(value)
    }
}

impl From<[u8;4]> for ChannelId {
    fn from(value: [u8;4]) -> Self {
        Self(u32::from_be_bytes(value))
    }
}

impl From<ChannelId> for u32 {
    fn from(value: ChannelId) -> Self {
        value.0
    }
}

impl From<ChannelId> for usize {
    fn from(value: ChannelId) -> Self {
        value.0 as usize
    }
}

impl From<ChannelId> for [u8;4] {
    fn from(value: ChannelId) -> Self {
        value.0.to_be_bytes()
    }
}