# Using Stardust

## Terminology
- **Transport layer:** Code that deals with sending octet strings over the internet, like UDP or WebRTC.
- **Octet string:** An arbitrary-length array of octets (bytes) that is used by the transport layer to convert to and from IP packets.
- **Protocol:** Shared agreement between the client and the server that allows compartmentalising network messages.
- **Protocol id:** A unique number generated by creating your Protocol, denying access to any clients with a different protocol ID.

## Setting up the protocol
You must mutably access the `ProtocolBuilder` resource to modify the protocol. This can only be done when setting up the `App`.

### Adding channels
Channels can be added with `builder.add_channel<T>(config)` or `app.add_net_channel<T>(config)`. Your channel will be accessed by `T` which must be implement `Channel` (auto-impl exists). You can easily do this by making a unit struct and using `#[derive(Debug)]`.

Both channel registration methods take a `ChannelConfig`, in which you can configure features you want your channel to have. They are as follows:
- **messages_per_tick_server** - Amount of memory to pre-allocate for incoming messages. Smaller values use less memory, but overrunning the allocated amount can be very slow.
- **messages_per_tick_client** - The same, but for the client.

The following options exist, but are not functional as of yet.
- **direction** - Whether the channel should ignore messages coming from a certain direction.
- **reliability** - Whether the channel should ensure that all packets from the channel arrive.
- **latestness** - Discards messages from older ticks, useful for information that must be about the latest state of the game.
- **ordering** - Whether the channel should ensure that messages will be read by systems in the order they are sent.
- **error_checking** - Adds extra information to try and ensure that the message payload is correct.
- **fragmentation** - Whether messages over the maximum data limit (currently 1,500 bytes) should be broken into multiple packets for transmission.
- **compression** - Whether or not the message data is compressed. Useful with channel fragmentation for very large messages.

### Replicating components
You can replicate components by adding a special Plugin to the app. There are two, `ReplicateComponentPluginBitstream` and `ReplicateComponentPluginReflected`. The Bitstream plugin is used for components that implement the `ManualBitSerialisation` trait, and the Reflected plugin is used for components that implement Bevy's `Reflect` trait. If possible, use the bitstream plugin, as the reflected plugin is extremely inefficient to serialise the component information. 

### Finishing up
Finally, use the `gen_protocol_id` function on the `App` to create your protocol ID. This will allow the protocol ID to change if Stardust's internal networking code changes, preventing issues. You must still change the information passed to the function if you change the plugins.
Alternatively, manually set it with `set_id` on the `ProtocolBuilder`. This keeps your protocol ID under your control, but can cause problems.

The `ProtocolBuilder` will be removed in the `finish` step for Bevy plugins, and an unchangeable `Protocol` object will be added to the `World` for your systems to use.

## Writing systems that use Stardust
### SystemParams
Stardust has the following system parameters you'll use in your systems.

*Note: Transport layer systemparams are documented in `transport.md`.*

#### Client
- `ConnectionManager` - Allows connecting/disconnecting from remote servers, and getting information like ping.
- `ChannelWrite<T>` - Allows writing octet strings to be sent over the network to the server.
- `ChannelRead<T>` - Allows reading octet strings sent over the network that were in channel `T`.

#### Server
- `ChannelWrite<T>` - Allows writing octet strings to be sent to a specific client, or groups of clients, or all clients.
- `ChannelRead<T>` - Allows reading octet strings sent over the network that were in channel `T`. Can be accessed by reading strings from specific clients, or reading every received packet.

### Schedules
```
PreUpdate (Bevy)
    NetworkPreUpdate
        TransportReadPackets
        ReadOctetStrings
        NetworkPreUpdateCleanup

Update (Bevy)
    Stardust doesn't do anything here.

PostUpdate (Bevy)
    NetworkPostUpdate
        WriteOctetStrings
        TransportSendPackets
        NetworkPostUpdateCleanup
```

#### TransportReadPackets
`TransportReadPackets` deals with reading raw IP packets and turning them into arbitrary-length octet strings for use by `ReadOctetStrings`.

This is only used for the **transport layer**, aka UDP or WebRTC. This is what deals with things like ordering and defragmentation and decryption.

#### ReadOctetStrings
`ReadOctetStrings` is the deserialisation step, reading the arbitrary-length octet strings processed by `TransportReadPackets` and applying it to the world. Since these are Bevy systems, you can do absolutely anything, such as writing `Events` and mutating components.

Octet strings can only be read during this schedule.

#### NetworkPreUpdateCleanup
`NetworkPreUpdateCleanup` is used to remove anything no longer needed from the `World` after all other stages.

#### WriteOctetStrings
`WriteOctetStrings` is the serialisation step, where systems read the world and write octets to be sent over the network.

Octet strings can only be written during this schedule.

#### TransportSendPackets
`TransportSendPackets` deals with converting the octet strings written by `WriteOctetStrings` to IP packets for transport. This involves things like ordering data, fragmentation, and encryption.

#### NetworkPostUpdateCleanup
`NetworkPostUpdateCleanup` is used to remove anything no longer needed from the `World` after sending packets.

## Adding to Stardust with Bevy plugins
Using the `expose_internals` feature flag lets you view some of the nuts and bolts of Stardust, useful if you're looking to optimise your network code.

**Put anything and everything that changes the protocol in a shared crate, or another solution that ensures that the protocol is identical on both the client and server.**